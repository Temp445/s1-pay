import { useEffect, useRef, useState } from 'react';
import { useAttendanceStore } from '../../../stores/attendanceStore';
import { identifyFace, initFaceRecognition } from '../../../lib/faceRecognition';
import { supabase } from '../../../lib/supabase';
import { Camera, ScanFace, AlertTriangle, CheckCircle, UserX, ShieldAlert } from 'lucide-react';
import { handleUnverifiedVisitor } from '../../../lib/visitorFaceCapture';
import { syncAttendanceLog } from '../../../lib/attendanceUtils';

/* ---------------- TYPES ---------------- */
type Status =
  | 'IDLE'
  | 'CHECKING_LIVENESS'
  | 'VERIFIED'
  | 'VISITOR_CAPTURED'
  | 'ERROR';

type FeedbackMessage = 
  | 'Looking for face...'
  | 'Too close! Move back.'
  | 'Too far! Come closer.'
  | '‚ö†Ô∏è Security: Photo/Screen Not Accepted'
  | 'Face not recognized (Visitor)'
  | 'Success!';

type TimingStatus = 'OK' | 'OUTSIDE_SHIFT' | 'NO_SHIFT_ASSIGNED';

const FACE_LOST_THRESHOLD = 20;

/* ---------------- COMPONENT ---------------- */

export default function FaceAttendancePage() {
  const { fetchAttendanceRecords } = useAttendanceStore();

  const videoRef = useRef<HTMLVideoElement>(null);
  const lockedEmployeeRef = useRef<string | null>(null);
  const faceLostCounterRef = useRef(0);
  
  const unverifiedFacePresentRef = useRef(false);
  const lastUnverifiedDescriptorRef = useRef<number[] | null>(null);
  const isProcessingRef = useRef(false);

  const [status, setStatus] = useState<Status>('IDLE');
  const [feedback, setFeedback] = useState<FeedbackMessage>('Looking for face...');
  const [verifiedEmployee, setVerifiedEmployee] = useState<{ id: string; name: string } | null>(null);

  useEffect(() => {
    initFaceRecognition().catch(console.error);
    startCamera();
    
    return () => {
        if (videoRef.current && videoRef.current.srcObject) {
            const tracks = (videoRef.current.srcObject as MediaStream).getTracks();
            tracks.forEach(track => track.stop());
        }
    }
  }, []);

  const startCamera = async () => {
    if (!videoRef.current) return;
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
        videoRef.current.srcObject = stream;
        await videoRef.current.play();
        recognizeLoop();
    } catch (err) {
        setFeedback('Camera Error: Permission Denied' as any);
        setStatus('ERROR');
    }
  };

  /* ---------------- RECOGNITION LOOP ---------------- */
  const recognizeLoop = async () => {
    if (!videoRef.current || isProcessingRef.current) {
        requestAnimationFrame(recognizeLoop);
        return;
    }

    if (lockedEmployeeRef.current) {
        requestAnimationFrame(recognizeLoop);
        return;
    }

    try {
      isProcessingRef.current = true;
      const result = await identifyFace(videoRef.current);

      /* --- NO FACE --- */
      if (result.reason === 'NO_FACE_DETECTED') {
        faceLostCounterRef.current++;
        if (faceLostCounterRef.current > FACE_LOST_THRESHOLD) {
             resetState();
        }
        setFeedback('Looking for face...');
        setStatus('IDLE');
      } 
      
      /* --- DISTANCE CHECKS --- */
      else if (result.reason === 'TOO_CLOSE') {
        faceLostCounterRef.current = 0;
        setFeedback('Too close! Move back.');
        setStatus('ERROR'); // Red Border
      } 
      else if (result.reason === 'TOO_FAR') {
        faceLostCounterRef.current = 0;
        setFeedback('Too far! Come closer.');
        setStatus('ERROR');
      }

      /* --- SPOOF / PHOTO DETECTED --- */
      // Use logical OR to catch both failure modes
      else if (result.reason === 'SPOOF_PHOTO_DETECTED' || result.reason === 'SPOOF_STATIC_DETECTED') {
        faceLostCounterRef.current = 0;
        // Explicit message for the user
        setFeedback('‚ö†Ô∏è Security: Photo/Screen Not Accepted');
        setStatus('ERROR');
        
        // Pause to let user read the warning
        await new Promise(r => setTimeout(r, 2000));
      }

      /* --- VISITOR --- */
      else if (result.reason === 'UNVERIFIED_FACE') {
        faceLostCounterRef.current = 0;
        setFeedback('Face not recognized (Visitor)');
        await handleVisitorLogic(result.descriptor);
      }

      /* --- SUCCESS --- */
      else if (result.matched && result.employeeId) {
        faceLostCounterRef.current = 0;
        lockedEmployeeRef.current = result.employeeId;
        
        const { data } = await supabase
          .from('employees')
          .select('name')
          .eq('id', result.employeeId)
          .maybeSingle();

        const empName = data?.name || 'Employee';
        handleSuccess({ id: result.employeeId, name: empName });
      }

    } catch (err) {
      console.error(err);
    } finally {
      isProcessingRef.current = false;
      requestAnimationFrame(recognizeLoop);
    }
  };

  const resetState = () => {
    lockedEmployeeRef.current = null;
    unverifiedFacePresentRef.current = false;
    lastUnverifiedDescriptorRef.current = null;
    setVerifiedEmployee(null);
    setStatus('IDLE');
  };

  const handleVisitorLogic = async (descriptor: any) => {
      try {
        const res = await handleUnverifiedVisitor({
          video: videoRef.current!,
          lastDescriptorRef: lastUnverifiedDescriptorRef,
          facePresentRef: unverifiedFacePresentRef,
        });
        if (res.success) {
            setStatus('VISITOR_CAPTURED');
            setFeedback('Face not recognized (Visitor)'); // Keep message generic
            await new Promise(r => setTimeout(r, 2000));
            resetState();
        }
      } catch (e) { console.error(e); }
  };

  /* ---------------- SUCCESS LOGIC ---------------- */
  const handleSuccess = async (employee: { id: string; name: string }) => {
    setVerifiedEmployee(employee);
    setFeedback('Success!');
    setStatus('VERIFIED');

    try {
        const today = new Date().toISOString().split('T')[0];
        const now = new Date();

        await fetchAttendanceRecords(employee.id, today, today);

        const { data: shifts } = await supabase
            .from('shift_assignments')
            .select(`shift_id, shifts(start_time, end_time)`)
            .eq('employee_id', employee.id)
            .eq('schedule_date', today);

        let shiftId: string | null = null;
        let timingStatus: TimingStatus = 'NO_SHIFT_ASSIGNED';

        if (shifts?.length) {
            const currentShift = shifts.find((s) => !isOutsideShift(s.shifts.start_time, s.shifts.end_time, now));
            if (currentShift) {
                shiftId = currentShift.shift_id;
                timingStatus = 'OK';
            } else {
                shiftId = shifts[0].shift_id;
                timingStatus = 'OUTSIDE_SHIFT';
            }
        }

        const lastEntry = await getLastEntry(employee.id, shiftId);
        const nextEntry = lastEntry === 'IN' ? 'OUT' : 'IN';

        await storeAttendanceTimestamp(employee.id, shiftId, nextEntry, timingStatus);
        await syncAttendanceLog(employee.id);

        await new Promise(r => setTimeout(r, 3000));
        resetState();

    } catch (err) {
        console.error(err);
        setFeedback('Error logging attendance' as any);
        setStatus('ERROR');
        await new Promise(r => setTimeout(r, 2000));
        resetState();
    }
  };

  /* --- Helpers --- */
  const isOutsideShift = (start: string, end: string, now: Date) => {
    const [sh, sm] = start.split(':').map(Number);
    const [eh, em] = end.split(':').map(Number);
    const s = new Date(now); s.setHours(sh, sm, 0, 0);
    const e = new Date(now); e.setHours(eh, em, 0, 0);
    if (e <= s) {
        e.setDate(e.getDate() + 1);
        if (now < s) s.setDate(s.getDate() - 1);
    }
    return now < s || now > e;
  };

  const getLastEntry = async (employeeId: string, shiftId: string | null) => {
    let query = supabase.from('attendance_timestamp').select('entry').eq('employee_id', employeeId).order('timestamp', { ascending: false }).limit(1);
    if (shiftId === null) query = query.is('shift_id', null);
    else query = query.eq('shift_id', shiftId);
    const { data } = await query.maybeSingle();
    return data?.entry ?? null;
  };

  const storeAttendanceTimestamp = async (employeeId: string, shiftId: string | null, entry: 'IN' | 'OUT', timingStatus: TimingStatus) => {
    await supabase.from('attendance_timestamp').insert({ employee_id: employeeId, shift_id: shiftId, entry, timing_status: timingStatus });
  };

  /* ---------------- UI RENDER ---------------- */
  const getBorderColor = () => {
    switch(status) {
        case 'VERIFIED': return 'border-green-500 shadow-green-200';
        case 'VISITOR_CAPTURED': return 'border-yellow-400 shadow-yellow-200';
        case 'ERROR': return 'border-red-500 shadow-red-200'; // Red for Too Close & Spoof
        case 'CHECKING_LIVENESS': return 'border-blue-500 animate-pulse';
        default: return 'border-gray-200';
    }
  };

  const StatusIcon = () => {
    if (status === 'VERIFIED') return <CheckCircle className="w-12 h-12 text-green-500 mb-2" />;
    // Show Alert Shield for Security errors
    if (feedback.includes('Security') || feedback.includes('Photo')) return <ShieldAlert className="w-12 h-12 text-red-600 mb-2 animate-pulse" />;
    if (status === 'ERROR') return <AlertTriangle className="w-12 h-12 text-red-500 mb-2" />;
    if (status === 'VISITOR_CAPTURED') return <UserX className="w-12 h-12 text-yellow-500 mb-2" />;
    return null;
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-[80vh] p-4">
      <div className="w-full max-w-md bg-white rounded-[2rem] shadow-2xl overflow-hidden transform transition-all">
        
        <div className="bg-gray-50 p-6 text-center border-b border-gray-100">
            <h2 className="text-2xl font-bold text-gray-800">Face Attendance</h2>
            <p className="text-sm text-gray-500 mt-1">Please stand still and look at the camera</p>
        </div>

        <div className="p-8 flex flex-col items-center">
            <div className={`relative w-64 h-64 rounded-full overflow-hidden border-[6px] transition-all duration-300 shadow-xl ${getBorderColor()}`}>
                <video
                    ref={videoRef}
                    autoPlay
                    muted
                    playsInline
                    className="w-full h-full object-cover transform scale-110"
                />
                
                {status === 'IDLE' && (
                    <div className="absolute inset-0 flex items-center justify-center bg-black/10 backdrop-blur-[1px]">
                         <ScanFace className="w-16 h-16 text-white/80 animate-pulse" />
                    </div>
                )}
            </div>
        </div>

        <div className="px-6 pb-8 min-h-[140px] flex flex-col items-center justify-center text-center">
            <StatusIcon />
            
            <h3 className={`text-xl font-bold mb-1 transition-colors duration-300
                ${status === 'ERROR' ? 'text-red-600' : 
                  status === 'VERIFIED' ? 'text-green-600' : 
                  status === 'VISITOR_CAPTURED' ? 'text-yellow-600' : 'text-gray-800'}`}>
                {verifiedEmployee ? verifiedEmployee.name : feedback}
            </h3>

            {/* Instruction for valid users */}
            {status === 'IDLE' && feedback !== 'Looking for face...' && (
                <p className="text-gray-500 text-sm mt-2 animate-bounce">
                    üëÅÔ∏è Blink eyes ‚Ä¢ ‚ÜîÔ∏è Turn head slightly
                </p>
            )}
            
            {status === 'VERIFIED' && (
                <p className="text-green-600 text-sm">
                   Marked at {new Date().toLocaleTimeString()}
                </p>
            )}
        </div>
      </div>
    </div>
  );
}